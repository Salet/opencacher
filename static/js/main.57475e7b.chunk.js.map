{"version":3,"sources":["services/constants.ts","services/caches.ts","helpers/geolocation.ts","pages/nearby/nearby.tsx","pages/app/app.tsx","serviceWorker.ts","index.tsx"],"names":["API_URL","CachesService","geopoint","URL","concat","latitude","longitude","fetch","then","response","json","codes","join","calculateGeoPointMeterDistance","a","b","latitudeDistance","Math","PI","longitudeDistance","haversine","sin","cos","atan2","sqrt","Nearby","props","state","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","cachesService","nearestCodes","nearestDetails","fetchCachesNearest","geolocation","handleCachesNearest","bind","assertThisInitialized","prevProps","setState","results","fetchCachesDetails","handleCachesDetails","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","code","value","push","objectSpread","distance","location","split","err","return","cache","react_default","createElement","className","name","round","type","rating","size2","terrain","recommendations","_this2","map","renderCache","Component","App","page","geolocationReliable","geolocationObject","navigator","geolocationEnabled","accuracy","orientationReliable","orientationRelativeEvents","window","orientationAbsoluteEvents","orientation","absolute","alpha","beta","gamma","webkitCompassHeading","addEventListener","handleOrientationEvent","getCurrentPosition","handlePositionEvent","enableHighAccuracy","event","toFixed","position","coords","console","log","href","onClick","setPage","JSON","stringify","nearby_Nearby","Boolean","hostname","match","ReactDOM","render","app_App","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.57475e7b.chunk.js","sourcesContent":["export const API_URL = \"https://opencaching.pl/okapi/\";\r\nexport const CONSUMER_KEY = \"?consumer_key=8v5yBJfdTpcsxEnzUPah\";\r\n","import { API_URL, CONSUMER_KEY } from \"./constants\";\r\nimport { Geopoint } from '../interfaces/geolocation';\r\n\r\nexport interface CachesDetailsResponse {\r\n  [code: string]: {\r\n    code: string;\r\n    name: string;\r\n    location: string;\r\n    status: string;\r\n    type: string;\r\n  };\r\n}\r\n\r\nexport interface CachesNearestResponse {\r\n  results: Array<string>;\r\n}\r\n\r\nexport default class CachesService {\r\n  fetchCachesNearest(geopoint: Geopoint): Promise<CachesNearestResponse> {\r\n    const ENDPOINT = \"services/caches/search/nearest\";\r\n    const URL = `${API_URL}${ENDPOINT}${CONSUMER_KEY}&center=${\r\n      geopoint.latitude\r\n      }|${geopoint.longitude}`;\r\n    return fetch(URL).then(response => response.json());\r\n  }\r\n\r\n  fetchCachesDetails(codes: Array<string>): Promise<CachesDetailsResponse> {\r\n    const ENDPOINT = \"services/caches/geocaches\";\r\n    const URL = `${API_URL}${ENDPOINT}${CONSUMER_KEY}&cache_codes=${codes.join(\r\n      \"|\"\r\n    )}&fields=code|name|location|type|status|size2|difficulty|terrain|rating|recommendations`;\r\n    return fetch(URL).then(response => response.json());\r\n  }\r\n}\r\n","import { Geopoint } from \"../interfaces/geolocation\";\r\n\r\nexport function calculateGeoPointMeterDistance(\r\n  a: Geopoint,\r\n  b: Geopoint\r\n): number {\r\n  let latitudeDistance = (b.latitude * Math.PI) / 180 - (a.latitude * Math.PI) / 180;\r\n  let longitudeDistance = (b.longitude * Math.PI) / 180 - (a.longitude * Math.PI) / 180;\r\n  let haversine =\r\n    Math.sin(latitudeDistance / 2) * Math.sin(latitudeDistance / 2) +\r\n    Math.cos((a.latitude * Math.PI) / 180) *\r\n    Math.cos((b.latitude * Math.PI) / 180) *\r\n    Math.sin(longitudeDistance / 2) *\r\n    Math.sin(longitudeDistance / 2);\r\n  return (\r\n    6378.137 *\r\n    2 *\r\n    Math.atan2(Math.sqrt(haversine), Math.sqrt(1 - haversine)) *\r\n    1000\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Geolocation } from '../../interfaces/geolocation';\r\nimport CachesService, { CachesNearestResponse, CachesDetailsResponse } from '../../services/caches';\r\nimport { calculateGeoPointMeterDistance } from '../../helpers/geolocation';\r\nimport './nearby.css';\r\n\r\ninterface NearbyProps {\r\n  geolocation: Geolocation;\r\n}\r\n\r\ninterface NearbyState {\r\n  nearestCodes: Array<string>;\r\n  nearestDetails: Array<{\r\n    distance: number;\r\n    code: string;\r\n    name: string;\r\n    location: string;\r\n    status: string;\r\n    type: string;\r\n  }>;\r\n}\r\n\r\nexport default class Nearby extends Component<NearbyProps, NearbyState> {\r\n  cachesService = new CachesService();\r\n\r\n  constructor(props: NearbyProps, state: NearbyState) {\r\n    super(props, state);\r\n    this.state = {\r\n      nearestCodes: [],\r\n      nearestDetails: []\r\n    };\r\n    this.cachesService.fetchCachesNearest(this.props.geolocation).then(this.handleCachesNearest.bind(this));\r\n  }\r\n\r\n  componentDidUpdate(prevProps: NearbyProps) {\r\n    if (this.props.geolocation.latitude !== prevProps.geolocation.latitude) {\r\n      this.cachesService.fetchCachesNearest(this.props.geolocation).then(this.handleCachesNearest.bind(this));\r\n    }\r\n  }\r\n\r\n  handleCachesNearest(response: CachesNearestResponse): void {\r\n    this.setState({ nearestCodes: response.results });\r\n    this.cachesService.fetchCachesDetails(this.state.nearestCodes).then(\r\n      this.handleCachesDetails.bind(this)\r\n    );\r\n  }\r\n\r\n  handleCachesDetails(response: CachesDetailsResponse): void {\r\n    let nearestDetails = [];\r\n    for (let code of this.state.nearestCodes) {\r\n      nearestDetails.push({\r\n        distance: calculateGeoPointMeterDistance(\r\n          {\r\n            latitude: this.props.geolocation.latitude,\r\n            longitude: this.props.geolocation.longitude\r\n          },\r\n          {\r\n            latitude: +response[code].location.split(\"|\")[0],\r\n            longitude: +response[code].location.split(\"|\")[1]\r\n          }\r\n        ),\r\n        ...response[code]\r\n      });\r\n    }\r\n    this.setState({ nearestDetails: nearestDetails });\r\n  }\r\n\r\n  renderCache(cache: any) {\r\n    return (\r\n      <div className=\"Nearby-cache\">\r\n        <h3>{cache.name}</h3>\r\n        <p>\r\n          Dystans: {Math.round(cache.distance)}m | Typ: {cache.type} | Ocena:{\" \"}\r\n          {cache.rating} | Rozmiar: {cache.size2} | Teren: {cache.terrain} |\r\n          Rekomendacje: {cache.recommendations}\r\n        </p>\r\n        <hr className=\"Nearby-separator\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"Nearby\">\r\n        {this.state.nearestDetails.map(cache => this.renderCache(cache))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./app.css\";\r\nimport Nearby from '../nearby/nearby';\r\nimport { Geolocation } from '../../interfaces/geolocation';\r\n\r\ntype Pages = 'nearby' | 'debug';\r\n\r\ninterface Orientation {\r\n  absolute: boolean;\r\n  alpha: number;\r\n  beta: number;\r\n  gamma: number;\r\n  webkitCompassHeading: number;\r\n}\r\n\r\ninterface AppState {\r\n  page: Pages;\r\n  geolocationReliable: boolean;\r\n  geolocationObject: boolean;\r\n  geolocationEnabled: boolean;\r\n  geolocation: Geolocation;\r\n  orientationReliable: boolean;\r\n  orientationRelativeEvents: boolean;\r\n  orientationAbsoluteEvents: boolean;\r\n  orientation: Orientation;\r\n}\r\n\r\nexport default class App extends Component<any, AppState> {\r\n\r\n  constructor(props: any) {\r\n    super(props);\r\n    this.state = {\r\n      page: 'debug',\r\n      geolocationReliable: false,\r\n      geolocationObject: !!navigator.geolocation,\r\n      geolocationEnabled: false,\r\n      geolocation: {\r\n        latitude: 0,\r\n        longitude: 0,\r\n        accuracy: 0\r\n      },\r\n      orientationReliable: false,\r\n      orientationRelativeEvents: \"ondeviceorientation\" in window,\r\n      orientationAbsoluteEvents: \"ondeviceorientationabsolute\" in window,\r\n      orientation: {\r\n        absolute: false,\r\n        alpha: 0,\r\n        beta: 0,\r\n        gamma: 0,\r\n        webkitCompassHeading: 0\r\n      }\r\n    };\r\n  }\r\n\r\n  componentWillMount() {\r\n    window.addEventListener(\r\n      this.state.orientationAbsoluteEvents ? \"deviceorientationabsolute\" : \"deviceorientation\",\r\n      this.handleOrientationEvent.bind(this),\r\n      true\r\n    );\r\n\r\n    if (this.state.geolocationObject) {\r\n      navigator.geolocation.getCurrentPosition(this.handlePositionEvent.bind(this), () => { }, { enableHighAccuracy: true });\r\n    }\r\n  }\r\n\r\n  handleOrientationEvent(event: any) {\r\n    if (!this.state.orientationReliable) {\r\n      this.setState({ orientationReliable: !!event.webkitCompassHeading || (event.absolute && !!event.alpha) });\r\n    }\r\n    this.setState({\r\n      orientation: {\r\n        absolute: event.absolute || false,\r\n        alpha: +(event.alpha || 0).toFixed(2),\r\n        beta: +(event.beta || 0).toFixed(2),\r\n        gamma: +(event.gamma || 0).toFixed(2),\r\n        webkitCompassHeading: +(event.webkitCompassHeading || 0).toFixed(2)\r\n      }\r\n    });\r\n  }\r\n\r\n  handlePositionEvent(position: Position) {\r\n    if (!this.state.geolocationEnabled) {\r\n      this.setState({ geolocationEnabled: true });\r\n    }\r\n    if (!this.state.geolocationReliable) {\r\n      this.setState({ geolocationReliable: !!position.coords.latitude || !!position.coords.longitude });\r\n    }\r\n    this.setState({\r\n      geolocation: {\r\n        latitude: position.coords.latitude,\r\n        longitude: position.coords.longitude,\r\n        accuracy: position.coords.accuracy,\r\n      }\r\n    });\r\n  }\r\n\r\n  setPage(page: Pages) {\r\n    console.log('page ', page)\r\n    this.setState({ page });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <h1>Opencacher</h1>\r\n        <div className=\"App-menu\">\r\n          <a href=\"#\" onClick={this.setPage.bind(this, 'nearby')}>Nearby</a> |&nbsp;\r\n          <a href=\"#\" onClick={this.setPage.bind(this, 'debug')}>Debug info</a>\r\n        </div>\r\n\r\n        {this.state.page == 'debug' && <div>\r\n          <p>Geolocation object: {this.state.geolocationObject ? \"yes\" : \"no\"}</p>\r\n          <p>Geolocation enabled: {this.state.geolocationEnabled ? \"yes\" : \"no\"}</p>\r\n          <p>Geolocation reading: {JSON.stringify(this.state.geolocation)}</p>\r\n          <b>Geolocation reliable: {this.state.geolocationReliable ? \"yes\" : \"no\"}</b>\r\n          <p>-----</p>\r\n          <p>\r\n            Orientation relative events:{\" \"}\r\n            {this.state.orientationRelativeEvents ? \"yes\" : \"no\"}\r\n          </p>\r\n          <p>\r\n            Orientation absolute events:{\" \"}\r\n            {this.state.orientationAbsoluteEvents ? \"yes\" : \"no\"}\r\n          </p>\r\n          <p>\r\n            Orientation webkit events:{\" \"}\r\n            {!!this.state.orientation.webkitCompassHeading ? \"yes\" : \"no\"}\r\n          </p>\r\n          <p>Orientation reading: {JSON.stringify(this.state.orientation)}</p>\r\n          <b>Orientation reliable: {this.state.orientationReliable ? \"yes\" : \"no\"}</b>\r\n        </div>}\r\n\r\n        {this.state.page == 'nearby' && <Nearby geolocation={this.state.geolocation}></Nearby>}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './pages/app/app';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}